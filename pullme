#!/usr/bin/env python

import yaml
import subprocess
import sys
import os
import re
import urllib2

def main():
    settings = load_settings()
    outstanding_changes = subprocess.check_output(
                            ['git', 'status', '--porcelain'])
    if outstanding_changes:
        confirm_continue()
    head_branch = determine_head_branch()
    push_to_personal(settings, head_branch)
    pull_target = determine_pull_target(settings)
    fork_path = determine_fork_path(settings)
    make_pull_request(fork_path, pull_target, head_branch)

def load_settings():
    settings = None
    try:
        config_file = open('%s/.pullmerc' % os.environ['HOME'])
        settings = yaml.load(config_file.read())
    except IOError, e:
        if e.errno != 2: #file not found
            raise e
    if not settings:
        settings = {} # an empty .pullmerc will load() to None
    if not settings.get('origin'):
        settings['origin'] = 'origin'
    if not settings.get('personal_remote'):
        settings['personal_remote'] = os.environ['USER']
    return settings

def confirm_continue():
    confirm = raw_input('There are outstanding changes. Continue? [Yn]')
    if confirm and confirm.lower() == 'n':
        sys.exit(1)
    elif confirm and confirm.lower() != 'y':
        print "I don't know what you mean by '%s'" % confirm
        confirm_continue()

def determine_head_branch():
    head_branch = subprocess.check_output(['git', 'name-rev',
                                        '--name-only', 'HEAD']).rstrip()
    print 'currently on %s' % head_branch
    return head_branch

def push_to_personal(settings, branch):
    print "pushing to %s/%s" % (settings['personal_remote'], branch)
    subprocess.check_call(['git', 'push', settings['personal_remote'],
                                                    'HEAD:%s' % branch])

def determine_pull_target(settings):
# look for the most recent reachable commit that has a corresponding ref name
# on origin, and return it.
    print 'looking for an appropriate pull request target branch'

# format:%d will show us all ref names for a commit.
# decorate=full ensures that we get refs/remotes in front of origin,
# insulating us from local branches that happen to have 'origin' in the name.
    command = "git log --decorate=full --pretty=format:%d"
    ref_names = subprocess.Popen([command], shell=True, stdout=subprocess.PIPE)

# Now we have a list of ref names that look something like this:
#
# (refs/remotes/origin/devel, refs/remotes/alorente/devel)
# (refs/remotes/origin/master)
#
# Git's rules on legal ref names are somewhat laxer than we might hope here.
# the name-terminating tokens, parens and commas, are both legal within names.
# This forces us into the rather awkward match you see below, rather than
# something like '([^,)]*)'. So it goes..
    origin_ref_line = ''
    while not origin_ref_line:
        line = ref_names.stdout.readline()
        if re.search('refs/remotes/%s' % settings['origin'], line):
            origin_ref_line = line.strip()
    ref_names.stdout.close()
    del ref_names
    if not origin_ref_line:
        raise Exception('could not find any ref names at all on %s\n'
            '(perhaps you have no remote called that?)' % settings['origin'])
    extract_branch_name = r'.*refs/remotes/%s/(.*?)(?:\)$|, ).*' % \
            settings['origin']
    pull_target = re.sub(extract_branch_name, r'\1', origin_ref_line)
    print 'looks like the target remote branch is %s/%s' % \
                                    (settings['origin'], pull_target)
    return pull_target

def determine_fork_path(settings):
# determine the path on github to the fork to which we're issuing a pull request
    remotes_info = subprocess.check_output(['git', 'remote', '-v']).split('\n')
    fork_url = filter(lambda x: re.search('fetch', x),
               filter(lambda x: re.search(settings['origin'], x),
               remotes_info))[0]
#now we have a thing that looks like
#origin git@github.com:emmadev/audience.git (fetch)
    fork_path = re.sub(r'.*github.com:(.*)\.git \(fetch\).*', r'\1', fork_url)
    print 'looks like we should submit a pull request to %s' % fork_path
    return fork_path

def make_pull_request(fork_path, pull_target, head_branch):
#TODO
    title = 'Get my shiz'
    body = 'Get this shiz up in here'
#can I put method in the headers like this?
    url = 'https://github.com/api/v2/json/pulls/%s' % fork_path
    data = '&'.join([
        'pull[base]=%s' % pull_target,
        'pull[head]=%s' % head_branch,
        'pull[title]=%s' % title,
        'pull[body]=%s' % body,
    ])
    request = urllib2.Request(url, data=data, headers={'method': 'POST'})
    urllib2.urlopen(request)

try:
    main()
except subprocess.CalledProcessError, e:
    sys.exit(e.returncode)


#TODO:
# * confirm that we have the right branch name
# * If the most recent reachable commit with a name on origin has multiple names
#         on origin, bail and ask for help
